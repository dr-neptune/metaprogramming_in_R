* Metaprogramming in R
:PROPERTIES:
:header-args: :session R-session :results output value table :colnames yes
:END:

Metaprogramming is when you write programs that manipulate other programs; in other words, you treat code as data that you can generalize, analyze, or modify. 

** Chapter 1 | Anatomy of a Function
*** Manipulating Functions

There are 3 parts to a function: 
- its formal parameters
- its body
- the environment its defined in


#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x) x

formals(f)

body(f)

environment(f)
#+END_SRC
*** Formals 

The formal parameters are given as a list where element names are the parameter names and values are default parameters 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
g <- function(x = 1, y = 2, z = 3) `+`(`+`(x, y), z)

parameters <- formals(g)

for (param in names(parameters)) cat(param, " => ", "'", parameters[[param]], "'", "\n", sep = "")
#+END_SRC

for variables in the list that do not have default values, the list represents the values as the empty name. This is a special symbol that you cannot assign to, so it cannot be confused with a real value. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
g <- function(x, y, z = 3) x + y + z

parameters <- formals(g)

for (param in names(parameters)) cat(param, " => ", "'", parameters[[param]], "'", " (", class(parameters[[param]]), ")\n", sep = "")

#+END_SRC

primitive functions (those that call into the runtime system) do not have formals

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
formals(`+`)
#+END_SRC
*** Function Bodies 

The function body is an expression. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
body(f)

# multistatement function
g <- function(x) {
    y <- 2*x
    z <- x**2
    x + y + z
}

body(g)
#+END_SRC

When a function is called, R sets up an environment for it to evaluate this expression in; this environment is called the evaluation environment for the function call. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
eval(body(f), envir = list(x = 2))
#+END_SRC

you can also set x as a default parameter (making an environment) when you evaluate the expression 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x = 2) x

formals(f)

eval(body(f), formals(f))
#+END_SRC

Things get weirded if the default parameters refer to each other 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x = y, y = 5) x + y

# both have default values, so we can call f without any arguments
f()

# we cannot evaluate it just from the formal arguments without providing values
eval(body(f), formals(f))
eval(body(f), { formals(f)$x <- 2; formals(f) })
#+END_SRC

Formal arguments are not evaluated when you call a function. They are transformed into promises, which are unevaluated expressions with an associated scope. 

When a function is called, each formal argument is assigned a promise in the local environment of the call with the expression slot containing the actual argument (if it exists) and the environment slot containing the environment of the caller. If no actual argument for a formal argument is given in the call and there is a default expression, it is similarly assigned to the expression slot of the formal argument, but with the environment set to the local environment. 

R first assigns all variables to promises, which are placeholders for values that are represented as expressions that haven't been evaluated yet. As soon as you access them, they will be evaluated and memoised. 

Since all promises are unevaluated expressions, you don't have to worry about the order in which you assign the variables. As long as the variables exist when you evaluate a promose and there are no circular variables, we are fine. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# don't do this
g <- function(x = 2*y, y = x/2) x + y
formals(g)
# you can try to make a similar setup for f where you build an env of its formals as promises. 
fenv <- new.env()
(parameters <- formals(f))
# we can use delayedAssign to assign values to promises
for (param in names(parameters)) delayedAssign(param, parameters[[param]], fenv, fenv)
eval(body(f), fenv)
#+END_SRC

*** Calling a Function 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
enclosing <- function() {
    z <- 2
    function(x, y = x) {
        x + y + z
    }
}

f <- enclosing()

calling <- function() {
    w <- 5
    f(x = 2 * w)
}

calling()
#+END_SRC

You can try to emulate all this using explicit environments and delayedAssign to store promises. You need 3 environments since you don't need to simulate the global environment for this. You need the environment where f was defined, called defenv, the environment for the call to f, evalenv, and the environment in which f is called, callenv. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
defenv <- new.env()
evalenv <- new.env(parent = defenv)
callenv <- new.env()

defenv$z <- 2
callenv$w <- 5
#+END_SRC

In the evaluation environment, you set up the promises. The delayedAssign function takes two environments as arguments. The first is where the promise should be evaluated, and the second is where it should be stored. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
delayedAssign("x", 2 * w, eval.env = callenv, assign.env = evalenv)
delayedAssign("y", x, eval.env = evalenv, assign.env = evalenv)
#+END_SRC

In the evalenv you can now evaluate f 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x, y = x) x + y + z

eval(body(f), evalenv)
#+END_SRC

*** Modifying Functions 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
(f <- function(x) x)

formals(f) <- list(x = 3)

eval(body(f), formals(f))
#+END_SRC

Evaluating a function is not quite as simple as evaluating its body in the context of its formals. It doesn't matter that you change a function's formal arguments outside of its definition when the function is invoked. The formal arguments will still be evaluated in the context where the function was defined. 

If we define a closure, we can see this in action 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
nested <- function() {
    y <- 5
    function(x) x
}

f <- nested()

formals(f) <- list(x = quote(y))

# if you call it without args, it will use its formals assignment (y)
f()

# R still evaluates promises for default parameters in scope
y <- 2
f()

# unless you provide y as a parameter when calling f
f(x = y)
#+END_SRC

We can also modify the body of f 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
body(f) <- 6
f

f()

f(x = 12)

body(f) <- 2 * y
f()

body(f) <- quote(2 * y)
f

f()
y <- 2
f()
#+END_SRC
 you can also change the environment if you want to make f use the global y 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
environment(f) <- globalenv()

f()
y <- 3
f()
#+END_SRC

If you want to set the formals of a function to missing values (that is, you want them to be parameters without default values), then you need to use list to create arguments 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x) x + y

# alist creates a pair list, which is an internal DS in R for formal arguments. 
formals(f) <- alist(x =, y =)
formals(f)

nested <- function() {
    y <- 5
    function(x) x
}

f <- nested()

formals(f) <- alist(x = y)
f
f()
#+END_SRC

*** Constructing Functions 

You can also construct new functions by piecing together their components. The function to use for this is as.function. It takes an alist as input and interprets the last element in it as the new function's body and the rest as formal arguments. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- as.function(alist(x =, y = 2, x + y))
f
f(2)
#+END_SRC

The environment of the new function is by default the environment in which you call as.function. So to make a closure, you can just call as.function inside another function 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
nested <- function(z) {
    as.function(alist(x =, y = z, x + y))
}

(g <- nested())
(h <- nested(4))
#+END_SRC

You can give an environment to as.function to specify the definition scope of the new function if you do not want it to be the current environment. In the following example, you have two functions for constructing closures. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
nested <- function(z) {
    as.function(alist(x =, y = z, x + y))
}

nested2 <- function(z) {
    as.function(alist(x =, y = z, x + y),
                envir = globalenv())
}

z <- -1

nested(3)(1)

nested2(3)(1)
#+END_SRC

** Chapter 2 | Inside a Function Call 

In the previous chapter, we saw how we could get a hold of the formal parameters of a function, the body of the function, and the environment in which the function was defined. In this chapter, we examine how we can access these, and more, from inside a function while the function is being evaluated. 

*** Getting the Components of the Current Function

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# sys.function gives the definition of the current function
f <- function(x = 5) {
    y <- 2 * x
    sys.function()
}

f

# since the function returns the definition of itself, we get the same when we evaluate it 
f()

# to get the formal parameters of a function inside a function, we can just use formals without any params
f <- function(x, y = 2 * x) formals()

params <- f(1, 2)

class(params)

params

# the same goes for the body of the current function
f <- function(x, y = 2 * x) {
    z <- x - y
    body()
}

f(2)

f <- function(x, y = 2 * x) {
    z <- x - y
    fformals <- formals(f)
    fbody <- body(f)
    list(fformals, fbody)
}

f(2)
#+END_SRC

The environment function works slightly differently. If you call it without parameters, you get the current evaluating environment 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function() {
    x <- 1
    y <- 2
    z <- 3
    (function(x, y, z) 2 * sum(sum(x, y), z))
    environment()
}

env <- f()

as.list(env)

# alternatively
environment(f)
#+END_SRC

To get the equivalent of environment(f) inside f, we must get a hold of the parent of the evaluating environ,ent. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function() {
    x <- 1; y <- 2; z <- 3;
    parent.env(environment())
}

f()
#+END_SRC

*** Accessing Actual Function Parameters 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# see difference between formal and actual parameters
f <- function(x = 1:3) {
    print(formals()$x)
    x
}

f(x = 4:6)
#+END_SRC


Formals gives the arg as given in the function definition, where x = 1:3. It is a promise, to be evaluated in the defining scope when you access x in the case when there are no params provided in the function call. 

If you actually want the arguments passed to the current function in the form of the promises they are really represented as, you need to get a hold of them without evaluating them. 

One way to get the expression that the promises represent is to use the function substitute. This function substitutes into an expression the values that the variables refer to. This means that variables are replaced by the verbatim expressions; the expressions are not evaluated before they are substituted into an expression. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x = 1:3) substitute(x)

# returns formal arguments
f()

# eval after 
eval(f())

f(5 * x)

f(foo + bar)

# because it is not evaluated, you don't even care if it -can- be evaluated
f(5 + "string")
#+END_SRC

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x = 1:3, y = x) substitute(x + y)
f()
f(x = 4:6)
f(y = 5 * x)

# environment is not preserved in the substitution 
x <- 5
f(x = 5 * x)
eval(f(x = 5 * x))

g <- function(x = 1:3, y = x) x + y
g(x = 5 * x)
#+END_SRC

A common use for substitute is to get the expression provided to a function as a string. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x) {
    cat(deparse(substitute(x)), "==", x)
}

f(2 + x)
f(1:4)
#+END_SRC

The actual type of the object returned by substitute depends on the expression you give the function and what the expression's variables refer to. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x) substitute(x)
f(5)
class(f(5))

# give substitute a local variable
f <- function(x) {
    y <- 2 * x
    substitute(y)
}

f(5)
class(f(5))

# if we call substitute in the global environment, it considers variables as names and does not substitute them for their values
x <- 5

class(substitute(5))
class(substitute(x))

# it will substitute variables for values if we give a function a simple type as an argument
f <- function(x, y = x) substitute(y)

f(5)
class(f(5))
f(5, 5)
class(f(5, 5))

# for anything more complicated, substitute returns a call object
f <- function(x, y) substitute(x + y)
f(5, 5)
class(f(5, 5))
#+END_SRC

A call object refers to an unevaluated function call. These can also be manipulated. We can translate it into a list to get its componenets, and we can evaluate it to invoke the actual function call

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
my_call <- f(5, 5)

as.list(my_call)
eval(my_call)
#+END_SRC

Since substitute doesn't evaluate a call, you can create function call objects with variables you can later evaluate in different environments. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
rm(x); rm(y)

my_call <- f(x, y)

as.list(my_call)

# x, y do not exist, so the call cannot be evaluted
eval(my_call)

# you can treat a call as a list and modify it
(my_call <- f(5, 5))

my_call[[1]] <- `-`
eval(my_call)

my_call[[2]] <- 10
eval(my_call)

# you can create call objects manually
(my_call <- call("+", 2, 2))
eval(my_call)

# unlike substitute, args to call are evaluated when the call object is constructed
x <- 5; y <- 2
(my_call <- call("+", x, y))
(my_call <- call("+", x - y, x + y))

# from inside a function, you can get the call used to invoke it using match.call
f <- function(x, y, z) {
    match.call()
}

(my_call <- f(2, 4, sin(2 + 4)))
as.list(my_call)

g <- f
(my_call <- g(2, 4, sin(2 + 4)))
my_call[[1]]
#+END_SRC

*** Accessing the Calling Scope 

Inside a function, expressions are evaluated in the scope defined by the evaluating environment and its parent environment, except for the promises provided in the function call, which are evaluated in the calling scope. If you want direct access to the calling environment, inside a function, you can get a hold of it using the function parent.frame

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
nested <- function(x) {
    function(local) {
        if (local) x
        else get("x", parent.frame())
    }
}

f <- nested(2)
f(TRUE)
x <- 1
f(FALSE)
#+END_SRC

In a slightly more complicated version, you can try evaluating an expression either in the local evaluating environment or in the calling scope 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
nested <- function(x) {
    y <- 2
    function(local) {
        z <- 2
        expr <- expression(x + y + z)
        if (local) eval(expr)
        else eval(expr, envir = parent.frame())
    }
}

f <- nested(2)

x <- y <- z <- 1

f(TRUE)
f(FALSE)
#+END_SRC

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
bind <- function(...) {
    # get all args into a pairlist without evaluation
    bindings <- eval(substitute(alist(...)))
    scope <- parent.frame()
    structure(list(bindings = bindings,
                   scope = scope,
                   class = "bindings"))
}

.unpack <- function(x) unname(unlist(x, use.names = FALSE))[1]

`%<-%` <- function(bindings, value) {
    var_names <- names(bindings$bindings)
    val_names <- names(value)
    has_names <- which(nchar(val_names) > 0)
    value_env <- list2env(as.list(value[has_names]),
                          parent = bindings$scope)

    for (i in seq_along(bindings$bindings)) {
        name <- var_names[i]
        if (length(var_names) == 0 || nchar(name) == 0) {
            variable <- bindings$bindings[[i]]
            if (!is.name(variable)) {
                stop(paste0("Positional variables cannot be expressions ",
                            deparse(variable), "\n"))
            }
            val <- .unpack(value[i])
            assign(as.character(variable), val, envir = bindings$scope)
        } else {
            assignment <- substitute(delayedAssign(name, expr,
                                                   eval.env = value_env,
                                                   assign.env = bindings$scope),
                                     list(expr = bindings$bindings[[i]]))
            eval(assignment)
        }
    }
    # force evaluation of variables to get rid of the lazy promises
    for (name in var_names) {
        if (nchar(name) > 0) force(bindings$scope[[name]])
    }
}

bind(x, y, z) %<-% 1:3
x; y; z

bind(y = 2 * x, z = 3 * x) %<-% c(x = 4)
c(x, y, z)

bind(y = 2 * z, z = 3 * x) %<-% c(x = 4)
c(x, y, z)
#+END_SRC

** Chapter 3 | Expressions and Environments 

This chapter digs deeper into how environments work and how you can evaluate expressions in different environments. 

*** Expressions 

In this chapter, we will focus on how expressions are evaluated and how we can change the scope when we evaluate an expression. 

*** Chains of Linked Environments 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
search()

library(MASS)
search()

# write a custom search function
my_search <- function(env) {
    repeat {
        name <- environmentName(env)
        if (nchar(name) != 0) name <- paste0(name, "\n")
        else name <- str(env, give.attr = FALSE)
        cat(name)
        env <- parent.env(env)
        if (identical(env, emptyenv())) break        
    }
}

my_search(globalenv())

get_envs <- function(s_env, env_ls = "") {
    if (identical(s_env, emptyenv())) env_ls
    else get_envs(parent.env(s_env),
                  paste(env_ls, cat(environmentName(s_env), "\n")))
}

f <- function() {
    g <- function() {
        h <- function() {
            function(x) x
        }
        h()
    }
    g()
}

# doesn't work due to lack of flow control for envs without names
get_envs(environment(f()), "")

# well done Thomas
my_search(environment(f()))

my_search(environment(ls))
my_search(environment(sd))
#+END_SRC

*** Environments and Function Calls

In day to day programming, it's more important to understand how environments and functions work together. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(x) {
    (g <- function(y, z) x + y + z)
}

h <- function(a) {
    g <- f(x)
    i <- function(b) g(a + b, 5)
}

x <- 2

i <- h(1)
i(3)
#+END_SRC

*** Manipulating Environments 

Not only can you access environments and put variables in them, but you can also modify the chain of parent environments. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function() {
    my_env <- environment()
    parent.env(my_env) <- parent.frame()
    x
}

g <- function(x) f()
g(2)
#+END_SRC

The main problem with doing this is that environments are mutable, so if you start modifying them in one place, it has consequences elsewhere. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function() {
    my_env <- environment()
    call_env <- parent.frame()
    parent.env(my_env) <- call_env
    y
}

g <- function(x) {
    closure <- function(y) {
        z <- f()
        z + x
    }
    closure
}

add1 <- g(1)
add2 <- g(2)

add1(3)
add2(4)

# setting a global variable x doesn't change the behavior
x <- 3
add1(3)
add2(4)

# break the closure without touching any of the called functions
f <- function() {
    my_env <- environment()
    call_env <- parent.frame()
    parent.env(my_env) <- call_env
    parent.env(call_env) <- parent.frame(2)
    y
}

# how if we don't have a global var x, the addition functions break
rm(x)

add1(3)

# even worse, if we do have x we get unexpected results
x <- 3
add1(3)
add2(4)
#+END_SRC

*** Explicitly Creating Environments 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
env <- new.env()
x <- 5

exists("x", env)
get("x", env)

f <- function() {
    x <- 7
    new.env()
}

env2 <- f()
get("x", env2)
#+END_SRC

You can assign variables to environments using assign or through the $<- function 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
assign("x", 3, envir = env)

env$x

(env$x <- 7)
#+END_SRC

All environments have a parent except the empty environment, but you can get the next best thing by making this environment the parent of your new one

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
global_x <- "foo"

env <- new.env(parent = emptyenv())

exists("global_x", env)
#+END_SRC

You can try to do something more interesting with manually created environments, such as building a parallel call stack you can use to implement dynamic scoping rather than lexical scoping. Lexical scoping is what we already have in R, where a function calls parent is the definition scope of the function. Dynamic scope instead has the calling environment. 

Since you don't want to mess around with the actual call stack and modify parent pointers, you need to make a parallel sequence of environments, and you need to copy the content of each call stack frame into these. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
copy_env <- function(from, to) {
    for (name in ls(from, all.names = TRUE)) assign(name, get(name, from), to)
}

# stop a little before the empty environment
show_env <- function(env) {
    if (!identical(env, globalenv())) {
        print(env)
        print(names(env))
        show_env(parent.env(env))
    }
}
#+END_SRC

Now comes the function for creating the parallel sequence of environments. You can use parent.frame to get the frames on the call stack arbitrarily deep - down to the first function call - and you can get the depth of the call stack using the function sys.nframe. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
build_caller_chain <- function() {
    n <- sys.nframe() - 1
    env <- globalenv()
    for (i in seq(1, n)) {
        env <- new.env(parent = env)
        frame <- parent.frame(n - i + 1)
        copy_env(frame, env)
    }
    env
}

# see it in action 
f <- function() {
    x <- 1
    function() {
        y <- 2
        function() {
            z <- 3
            print("---Enclosing Environments---")
            show_env(environment())

            call_env <- build_caller_chain()
            print("---Calling Environments---")
            show_env(call_env)
        }
    }
}

g <- f()()

h <- function() {
    x <- 4; y <- 5
    g()
}

h()
#+END_SRC

*** Environments and Expression Evaluation 

This section covers how you combine expressions and environments to compute values. All you have to do to evaluate an expression in any selected environment is to provide it to the eval function. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function() {
    x <- 1
    function() {
        y <- 2
        function() {
            z <- 3

            cat("Lexical Scope: ", x + y + z, "\n")

            call_env <- build_caller_chain()
            cat("Dynamic Scope: ", eval(quote(x + y + z), call_env), "\n")
        }
    }
}

g <- f()()

h <- function() {
    x <- 4; y <- 5
    g()
}

h()
#+END_SRC

** Chapter 4 | Manipulating Environments

Expressions, the kind created using the quote function, come in 4 flavors: 
- a primitive value
- a name
- a function call or control structure
- a pairlist 

pairlists are used for dealing with function parameters, so unless you are working with function arguments, you won't see them in expressions. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
class(quote(1))
class(quote("foo"))
class(quote(TRUE))
class(quote(x))
class(quote(f(x)))
class(quote(2 + 2))
class(quote(if (TRUE) "foo" else "bar"))
class(quote(for (x in 1:3) x))
#+END_SRC

Calls and control structures capture the action in an expression; you can treat these as lists, and thus examine and modify them. Working with expressions this way is the topic of this chapter. Substituting values for variables is another, complimentary way that is the topic of the next chapter. 

*** Accessing and Manipulating Control Structures 

Statements involving control structures are expressions like any other expressions in R, and you can create an unevaluated version of them using quote. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
(x <- quote(if (foo) bar))
length(x)
x[[3]]

(y <- quote(if (foo) bar else baz))
y[[4]]

(z <- quote(for (x in 1:4) print(x)))
z[[4]]

# eval like any other expression 
eval(z)

# modify to change behavior before eval 
z[[3]] <- 1:10
eval(z)

# change what happens in the function body
z[[4]] <- quote(print(x + 2))
eval(z)

# change both index variable and body 
z[[2]] <- quote(y)
z[[4]] <- quote(print(y))
eval(z)
#+END_SRC

*** Accessing and Manipulating Function Calls 

For function calls, their class is call, and when you treat them as lists, the first element is the name of the function being called, and the remaining elements are the function call elements. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
(x <- quote(f(x, y, z)))

class(x)

length(x)

for (i in 1:4) print(x[[i]])

# test whether an expression is a function call
is.call(quote(x))
is.call(quote(f(x)))

# change the expression when it gets evaluated
x <- quote(sin(2))
eval(x)

x[[1]] <- quote(cos)
eval(x)

x[[2]] <- 0
eval(x)
#+END_SRC

To explore an expression, you usually need a recursive function. The two basic cases in a recursion are is.call for function calls and is.pairlist if you want to deal with those. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
f <- function(expr, indent = "") {
    if (is.atomic(expr) || is.name(expr)) {
        print(paste0(indent, expr))
    } else if (is.call(expr)) {
        print(paste0(indent, expr[[1]]))
        n <- length(expr)
        if (n > 1) {
            new_indent <- paste0(indent, " ")
            for (i in 2:n) {
                f(expr[[i]], new_indent)
            }
        }
    } else {
        print(paste0(indent, "Unexpected expression: ", expr[[1]]))
    }
}

f(quote(2 + 3 * (x + y)))
#+END_SRC

*** Expression Simplification 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
simplify_expr <- function(expr) {
    if (is.atomic(expr) || is.name(expr)) expr
    else if (is.call(expr)) simplify_call(expr)
    else stop(paste0("Unexpected expression ", deparse(expr), " in simplifying"))
}

simplify_call <- function(expr) {
    if (is.name(expr[[1]])) {
        # addition
        if (expr[[1]] == as.name("+")) return(simplify_addition(expr[[2]], expr[[3]]))
        # subtraction
        if (expr[[1]] == as.name("-")) {
            if (length(expr) == 2)
                return(simplify_unary_subtraction(expr[[2]]))
            else return(simplify_subtraction(expr[[2]], expr[[3]]))
        }
        # multiplication
        if (expr[[1]] == as.name("*"))
            return(simplify_multiplication(expr[[2]], expr[[3]]))
        # division
        if (expr[[1]] == as.name("/"))
            return(simplify_division(expr[[2]], expr[[3]]))
        # exponentiation
        if (expr[[1]] == as.name("^"))
            return(simplify_exponentiation(expr[[2]], expr[[3]]))
        # parentheses
        if (expr[[1]] == as.name("(")) {
            subexpr <- simplify_expr(expr[[2]])
            if (is.atomic(subexpr) || is.name(subexpr)) return(subexpr)
            else if (is.call(subexpr) && subexpr[[1]] == as.name("(")) return(subexpr)
            else return(call("(", subexpr))
        }}
    simplify_function_call(expr)
}
#+END_SRC

You must compare the call names with name objects, since they are of the type name, not character. Also subtraction comes in two flavors: binary subtraction and unary negation; we can tell these apart by the number of args. Also parentheses are also calls, so they must be handled. 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
# handle each operator in turn
simplify_addition <- function(f, g) {
    left <- simplify_expr(f)
    right <- simplify_expr(g)

    if (left == 0) return(right)
    if (right == 0) return(left)
    if (is.numeric(right) && is.numeric(right)) return(left + right)
    call("+", left, right)
}

simplify_addition(quote("2"), quote("6"))
simplify_addition(quote(2), quote("6"))
simplify_addition(quote(2), quote(6))

simplify_unary_subtraction <- function(f) {
    simplified <- simplify_expr(f)
    if (is.numeric(simplified)) -simplified
    else if (is.call(simplified) && simplified[[1]] == "-")
        simplified[[2]]
    # bquote subs a value where you put .(...) -> quote(-simplified)
    else bquote(-.(simplified))
}

simplify_unary_subtraction(quote(-5))
simplify_unary_subtraction(quote("5"))
simplify_unary_subtraction(quote(-"5"))

simplify_subtraction <- function(f, g) {
    left <- simplify_expr(f); right <- simplify_expr(g)
    if (left == 0) {
        if (is.numeric(right)) return(-right)
        else return(bquote(-.(right)))
    }
    if (right == 0) return(left)
    if (is.numeric(left) && is.numeric(right)) return(left - right)
    call("-", left, right)
}

simplify_subtraction(quote(-5), quote("-5"))

simplify_multiplication <- function(f, g) {
    left <- simplify_expr(f); right <- simplify_expr(g)
    if (left == 0 || right == 0) return(0)
    if (left == 1) return(right)
    if (right == 1) return(left)
    if (is.numeric(left) && is.numeric(right)) return(left * right)
    call("*", left, right)
}

simplify_division <- function(f, g) {
    left <- simplify_expr(f); right <- simplify_expr(g)
    if (right == 1) return(left)
    if (is.numeric(left) && is.numeric(right)) return(left / right)
    call("/", left, right)
}

simplify_exponentiation <- function(f, g) {
    left <- simplify_expr(f); right <- simplify_expr(g)
    if (right == 0) return(1)
    if (left == 0) return(0)
    if (left == 1) return(1)
    if (right == 1) return(left)
    if (is.numeric(left) && is.numeric(right)) return(left ^ right)
    call("^", left, right)
}

simplify_function_call <- function(expr) {
    function_name <- expr[[1]]
    arguments <- vector("list", length(expr) - 1)
    for (i in seq_along(arguments)) {
        arguments[i] <- list(simplify_expr(expr[[i + 1]]))
    }

    if (all(unlist(Map(is.numeric, arguments)))) {
        if (as.character(function_name) %in% c("sin", "cos", "exp", "log")) {
            result <- do.call(as.character(function_name), arguments)
            return(result)
        }
    }
    as.call(c(list(function_name), arguments))
}

simplify_expr(quote(2 * (0 + ((4 + 5) * x) * 1)))

f <- function(x, y) x
exp1 <- quote(f(x = 2, y = 1))
exp2 <- quote(f(y = 2, x = 1))

eval(exp1)
eval(exp2)

simplify_expr(exp1)
simplify_expr(exp2)

eval(simplify_expr(exp1))
eval(simplify_expr(exp2))
#+END_SRC

*** Automatic Differentiation 

#+BEGIN_SRC R :post round-tbl[:colnames yes](*this*)
d <- function(f, x) {
    if (is.null(body(f))) {
        if (identical(f, sin)) return(cos)
        if (identical(f, cos)) return(- sin(x))
        if (identical(f, exp)) return(exp)
        stop("Unknown primitive")
    } else {
        df <- f
        e <- environment(f)
        body(df) <- simplify_expr(diff_expr(body(f), x, e))
        df
    }
}

diff_expr <- function(expr, x, e) {
    if (is.numeric(expr)) quote(0)
    else if (is.name(expr)) {
        if (expr == x) quote(1)
        else quote(0)
    } else if (is.call(expr)) diff_call(expr, x, e)
    else stop(paste0("Unexpected expression ", deparse(expr), "in parsing."))
}

.built_in_functions <- c("sin", "cos", "exp")

diff_call <- function(expr, x, e) {
    if (is.name(expr[[1]])) {
        if (expr[[1]] == as.name("+"))
            return(diff_addition(expr[[2]], expr[[3]], x, e))
        if (expr[[1]])
    }

#+END_SRC
